What was the problem you were solving in the projects for this course?

In Project One, the problem was to analyze the runtime and memory usage of different data structures—vector, hash table, and binary search tree—when managing course data. In Project Two, the task was to develop a program that sorts and prints a list of courses in the Computer Science program in alphanumeric order.


How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by evaluating the efficiency of each data structure in terms of runtime and memory usage. Understanding data structures is crucial because they determine how data is stored, accessed, and manipulated, impacting the performance and scalability of applications. For Project Two, I used a hash table to efficiently store and retrieve course data, leveraging its average constant time complexity for quick access.


How did you overcome any roadblocks you encountered while going through the activities or project?

I encountered challenges with handling file input and ensuring data was correctly parsed and stored. To overcome these, I carefully reviewed the file handling logic and used debugging techniques to identify and fix issues. I also consulted documentation and resources to better understand the nuances of the data structures I was working with.


How has your work on this project expanded your approach to designing software and developing programs?

This project expanded my approach by emphasizing the importance of choosing the right data structure for the task at hand. It reinforced the need for thorough analysis and testing to ensure optimal performance. I also learned the value of clear and maintainable code, which is crucial for long-term project success.


How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

My work on this project has taught me to prioritize code readability and maintainability by using clear variable names, consistent formatting, and comprehensive comments. I also learned to design programs with adaptability in mind, ensuring that future changes or extensions can be easily integrated without major overhauls.
